diff --git a/.claude/settings.local.json b/.claude/settings.local.json
index 75638867ff..19a0c07618 100644
--- a/.claude/settings.local.json
+++ b/.claude/settings.local.json
@@ -25,7 +25,8 @@
       "Bash(git add:*)",
       "Bash(git commit:*)",
       "Bash(git checkout:*)",
-      "Bash(gh issue view:*)"
+      "Bash(gh issue view:*)",
+      "Bash(git apply:*)"
     ],
     "deny": [],
     "ask": [],
diff --git a/src/main/java/com/divudi/bean/pharmacy/PharmacySaleController.java b/src/main/java/com/divudi/bean/pharmacy/PharmacySaleController.java
index cb54141f06..6461b7e28e 100644
--- a/src/main/java/com/divudi/bean/pharmacy/PharmacySaleController.java
+++ b/src/main/java/com/divudi/bean/pharmacy/PharmacySaleController.java
@@ -1166,13 +1166,68 @@ public class PharmacySaleController implements Serializable, ControllerWithPatie
         this.stock = stock;
     }
 
+    /**
+     * Converts a StockDTO to a minimal Stock entity without database queries.
+     * Creates detached entities populated only with data from the DTO.
+     * This avoids JPA proxy issues and LazyInitializationException.
+     *
+     * @param stockDto The DTO containing all necessary data
+     * @return A minimal Stock entity with ItemBatch and Item populated from DTO
+     */
     public Stock convertStockDtoToEntity(StockDTO stockDto) {
         if (stockDto == null || stockDto.getId() == null) {
             return null;
         }
+
+        // Check if we have the necessary data for lightweight creation
+        if (stockDto.getItemBatchId() != null && stockDto.getItemId() != null) {
+            // Create minimal Stock entity with data from DTO
+            Stock stock = new Stock();
+            stock.setId(stockDto.getId());
+            stock.setStock(stockDto.getStockQty());
+
+            // Create minimal ItemBatch with data from DTO
+            ItemBatch itemBatch = new ItemBatch();
+            itemBatch.setId(stockDto.getItemBatchId());
+            itemBatch.setRetailsaleRate(stockDto.getRetailRate());
+            itemBatch.setDateOfExpire(stockDto.getDateOfExpire());
+            itemBatch.setBatchNo(stockDto.getBatchNo());
+
+            // Create minimal Item (we use Amp as a concrete implementation)
+            // Note: This is a detached entity used only for reference
+            // The actual fetch happens when saving the bill if needed
+            Item item = createMinimalItemFromDto(stockDto);
+
+            itemBatch.setItem(item);
+            stock.setItemBatch(itemBatch);
+
+            return stock;
+        }
+
+        // Fallback to database fetch if DTO doesn't have all required data
+        // This ensures backward compatibility with existing code
         return stockFacade.find(stockDto.getId());
     }
 
+    /**
+     * Creates a minimal Item entity from StockDTO data.
+     * Since Item is abstract, we create an Amp instance.
+     * This is safe because we only use properties set from DTO data.
+     *
+     * @param stockDto The DTO containing item data
+     * @return A minimal Amp instance with properties from DTO
+     */
+    private Item createMinimalItemFromDto(StockDTO stockDto) {
+        // Create a minimal Amp instance (Item is abstract)
+        Amp item = new Amp();
+        item.setId(stockDto.getItemId());
+        item.setName(stockDto.getItemName());
+        item.setCode(stockDto.getCode());
+        // Set discountAllowed from DTO, defaulting to true for safety
+        item.setDiscountAllowed(stockDto.getDiscountAllowed() != null ? stockDto.getDiscountAllowed() : true);
+        return item;
+    }
+
     public StockDTO getStockDto() {
         return stockDto;
     }
@@ -1540,8 +1595,8 @@ public class PharmacySaleController implements Serializable, ControllerWithPatie
                 "Enable search medicines by generic name(VMP)", false);
 
         StringBuilder sql = new StringBuilder("SELECT NEW com.divudi.core.data.dto.StockDTO(")
-                .append("i.id, i.itemBatch.item.name, i.itemBatch.item.code, i.itemBatch.item.vmp.name, ")
-                .append("i.itemBatch.retailsaleRate, i.stock, i.itemBatch.dateOfExpire) ")
+                .append("i.id, i.itemBatch.id, i.itemBatch.item.id, i.itemBatch.item.name, i.itemBatch.item.code, i.itemBatch.item.vmp.name, ")
+                .append("i.itemBatch.batchNo, i.itemBatch.retailsaleRate, i.stock, i.itemBatch.dateOfExpire, i.itemBatch.item.discountAllowed) ")
                 .append("FROM Stock i ")
                 .append("WHERE i.stock > :stockMin ")
                 .append("AND i.department = :department ")
@@ -1566,12 +1621,26 @@ public class PharmacySaleController implements Serializable, ControllerWithPatie
         return (List<StockDTO>) getStockFacade().findLightsByJpql(sql.toString(), parameters, TemporalType.TIMESTAMP, 20);
     }
 
+    /**
+     * Handles item selection from autocomplete.
+     * Converts DTO to minimal entity (no database query) and calculates rates.
+     */
     public void handleSelectAction() {
+        if (stockDto == null) {
+            return;
+        }
+
+        // Convert DTO to minimal entity (no database query)
+        this.stock = convertStockDtoToEntity(stockDto);
+
         if (stock == null) {
             return;
         }
+
         getBillItem().getPharmaceuticalBillItem().setStock(stock);
         calculateRatesOfSelectedBillItemBeforeAddingToTheList(billItem);
+
+        // Instructions will be loaded when needed (lazy)
         pharmacyService.addBillItemInstructions(billItem);
     }
 
diff --git a/src/main/java/com/divudi/core/data/dto/StockDTO.java b/src/main/java/com/divudi/core/data/dto/StockDTO.java
index 2fb6432fbb..308167f598 100644
--- a/src/main/java/com/divudi/core/data/dto/StockDTO.java
+++ b/src/main/java/com/divudi/core/data/dto/StockDTO.java
@@ -9,6 +9,7 @@ public class StockDTO implements Serializable {
     private Long id;
     private Long stockId;
     private Long itemBatchId;
+    private Long itemId;
     private String itemName;
     private String code;
     private String genericName;
@@ -35,6 +36,8 @@ public class StockDTO implements Serializable {
     private Double totalStockQty;
     // Whether the underlying Item allows fractional quantities
     private Boolean allowFractions = false;
+    // Whether the underlying Item allows discounts (prevents database queries during rate calculation)
+    private Boolean discountAllowed = true;  // Default to true for safety
 
     public StockDTO() {
     }
@@ -197,6 +200,23 @@ public class StockDTO implements Serializable {
         this.allowFractions = allowFractions;
     }
 
+    // Constructor for optimized retail sale autocomplete (includes itemBatchId and itemId for zero-query conversion)
+    public StockDTO(Long id, Long itemBatchId, Long itemId, String itemName, String code,
+                    String genericName, String batchNo, Double retailRate, Double stockQty,
+                    Date dateOfExpire, Boolean discountAllowed) {
+        this.id = id;
+        this.itemBatchId = itemBatchId;
+        this.itemId = itemId;
+        this.itemName = itemName;
+        this.code = code;
+        this.genericName = genericName;
+        this.batchNo = batchNo;
+        this.retailRate = retailRate;
+        this.stockQty = stockQty;
+        this.dateOfExpire = dateOfExpire;
+        this.discountAllowed = discountAllowed;
+    }
+
     public Long getId() {
         return id;
     }
@@ -221,6 +241,14 @@ public class StockDTO implements Serializable {
         this.itemBatchId = itemBatchId;
     }
 
+    public Long getItemId() {
+        return itemId;
+    }
+
+    public void setItemId(Long itemId) {
+        this.itemId = itemId;
+    }
+
     public String getItemName() {
         return itemName;
     }
@@ -389,4 +417,17 @@ public class StockDTO implements Serializable {
     public void setTotalStockQty(Double totalStockQty) {
         this.totalStockQty = totalStockQty;
     }
+
+    public Boolean getDiscountAllowed() {
+        return discountAllowed;
+    }
+
+    public void setDiscountAllowed(Boolean discountAllowed) {
+        this.discountAllowed = discountAllowed;
+    }
+
+    // Prefer boolean accessor for EL friendliness
+    public boolean isDiscountAllowed() {
+        return discountAllowed != null && discountAllowed;
+    }
 }
